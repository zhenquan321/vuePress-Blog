(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{410:function(v,_,t){"use strict";t.r(_);var l=t(43),i=Object(l.a)({},function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"框架通用面试题"}},[v._v("框架通用面试题")]),v._v(" "),t("h2",{attrs:{id:"为什么选择使用框架而不是原生"}},[v._v("为什么选择使用框架而不是原生?")]),v._v(" "),t("p",[v._v("框架的好处:")]),v._v(" "),t("ol",[t("li",[v._v("组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。")]),v._v(" "),t("li",[v._v("天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。")]),v._v(" "),t("li",[v._v("生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案。")]),v._v(" "),t("li",[v._v("开发效率: 现代前端框架都默认自动更新DOM,而非我们手动操作,解放了开发者的手动DOM成本,提高开发效率,从根本上解决了UI 与状态同步问题.")])]),v._v(" "),t("h2",{attrs:{id:"虚拟dom的优劣如何"}},[v._v("虚拟DOM的优劣如何?")]),v._v(" "),t("p",[v._v("优点:")]),v._v(" "),t("ul",[t("li",[v._v("保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限")]),v._v(" "),t("li",[v._v("无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率")]),v._v(" "),t("li",[v._v("跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等")])]),v._v(" "),t("p",[v._v("缺点:")]),v._v(" "),t("ul",[t("li",[v._v("无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化")])]),v._v(" "),t("h2",{attrs:{id:"虚拟dom实现原理"}},[v._v("虚拟DOM实现原理?")]),v._v(" "),t("ul",[t("li",[v._v("虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象")]),v._v(" "),t("li",[v._v("状态变更时，记录新树和旧树的差异")]),v._v(" "),t("li",[v._v("最后把差异更新到真正的dom中")])]),v._v(" "),t("blockquote",[t("p",[v._v("详细实现见"),t("router-link",{attrs:{to:"./virtualDom.html"}},[v._v("虚拟DOM原理?")])],1)]),v._v(" "),t("hr")])},[],!1,null,null,null);i.options.__file="common.md";_.default=i.exports}}]);